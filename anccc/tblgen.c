/*
    tblgen.c: table generator
    Aean, 2014.7.9
*/

#include "anccc.h"

char* action(int state, int sym, char* act){
    item_t* p = setfamily[state]->item;
    char tact[16] = {0};
    item_t* pconflict = p;
    *act = 0;
    while(p){
        if(sym==NAL && rule_list[p->rule].left==whole_file && rule_list[p->rule].r[p->p]==EOL){
            sprintf(tact, " ACC");
            if(*act && strcmp(act, tact)){
                char sel = 1;
                printf("\r                         \n"
                       "Conflict encountered at state %d symbol %s.\n", state, nameofsym(sym));
                printitem(pconflict);
                printitem(p);
                printf("Please give a manual choose between %s versus %s?[1/2, default 1]:", act, tact);
                scanf("%c", &sel);
                while(getchar()!='\n');
                if(sel=='2'){
                    pconflict = p;
                    strcpy(act, tact);
                }
            }else{
                pconflict = p;
                strcpy(act, tact);
            }
        }else if(rule_list[p->rule].r[p->p]==sym){
            sprintf(tact, "S(%d)", migrate(state, sym));
            if(*act && strcmp(act, tact)){
                char sel = 1;
                printf("\r                         \n"
                       "Conflict encountered at state %d symbol %s.\n", state, nameofsym(sym));
                printitem(pconflict);
                printitem(p);
                printf("Please give a manual choose between %s versus %s?[1/2, default 1]:", act, tact);
                scanf("%c", &sel);
                while(getchar()!='\n');
                if(sel=='2'){
                    pconflict = p;
                    strcpy(act, tact);
                }
            }else{
                pconflict = p;
                strcpy(act, tact);
            }
        }else if(rule_list[p->rule].r[p->p]==EOL && p->la==sym){
            sprintf(tact, "R(%d)", p->rule);
            if(*act && strcmp(act, tact)){
                char sel = 1;
                printf("\r                         \n"
                       "Conflict encountered at state %d symbol %s.\n", state, nameofsym(sym));
                printitem(pconflict);
                printitem(p);
                printf("Please give a manual choose between %s versus %s?[1/2, default 1]:", act, tact);
                scanf("%c", &sel);
                while(getchar()!='\n');
                if(sel=='2'){
                    strcpy(act, tact);
                    pconflict = p;
                }
            }else{
                pconflict = p;
                strcpy(act, tact);
            }
        }
        p=p->next;
    }
    if(!*act) sprintf(act, "E(0)");
    return act;
}

void writetbl(){
    FILE* f = fopen("parsetbl.c", "wb");
    int i, j;
    char buf[32];
    printf("\nGenerating ACTION table.\n");
    fprintf(f, "/*\n"
            "    parsetbl.c: the Canonical LR(1) parse table.\n"
            "    This file is generated by anccc automatically.\n"
            "    Licensed under the terms of the MIT License.\n"
            "*/\n\n");
    fprintf(f, "#include \"ancc.h\"\n\n"
            "#define S(v) (v)\n"
            "#define ACC (2147483647)\n"
            "#define R(v) ((v) + %Iu) /* familycount = %Iu */\n"
            "#define E(v) (-((v)+1))\n\n", familycount, familycount);
    fprintf(f, "const int action_tbl[][%d] = {\n", NAL + 1);
    for(i=0; i < familycount; i++){
        fprintf(f, "/* state%5d", i);
        for(j=0; j<=NAL; j++){
            char* n = nameofsym(j);
            fprintf(f, "%12s ", n);
        }
        fprintf(f, "*/\n    {        ");
        for(j=0; j<=NAL; j++){
            memset(buf, 0, 12);
            action(i, j, buf);
            fprintf(f, "%12s,", buf);
        }
        fprintf(f, "},\n");
        if (i & 15){
            printf("\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b");
            putchar('[');
            int n;
            for( n = i * 21 / familycount; n >= 0; n-- )
                putchar('=');
            putchar('>');
            for( n = i * 21 / familycount; n < 20; n++ )
                putchar('_');
            putchar(']');
        }
    }
    fprintf(f, "};\n\n");
    printf("\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b");
    printf("[=====================>]\n");
    printf("\nGenerating GOTO table.\n");
    fprintf(f, "const int goto_tbl[][%d] = {\n", EOL - NAL - 1);
    for(i=0; i < familycount; i++){
        fprintf(f, "/* state%5d", i);
        for(j=NAL+1; j<EOL; j++){
            fprintf(f, "%32s", nameofsym(j));
        }
        fprintf(f, "*/\n    {        ");
        for(j=NAL+1; j<EOL; j++){
            fprintf(f, "%31d,", migrate(i, j));
        }
        fprintf(f, "},\n");
        if (i & 15){
            printf("\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b");
            putchar('[');
            int n;
            for( n = i * 21 / familycount; n >= 0; n-- )
                putchar('=');
            putchar('>');
            for( n = i * 21 / familycount; n < 20; n++ )
                putchar('_');
            putchar(']');
        }
    }
    fprintf(f, "};");
    printf("\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b");
    printf("[=====================>]\n");
    fflush(f);
    fclose(f);
}
